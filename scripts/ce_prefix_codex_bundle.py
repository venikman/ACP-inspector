#!/usr/bin/env python3
"""
Post-process a Codex bundle generated by @every-env/compound-plugin:
- Prefix all prompt filenames and skill directory names (default: "ce-")
- Rewrite internal references:
  - $skill references
  - /prompts: references
  - frontmatter "name:" in SKILL.md
  - ${CLAUDE_PLUGIN_ROOT}/skills/<skill>/... paths -> .codex/skills/<prefixed-skill>/...

This keeps the imported bundle project-local and avoids collisions with global Codex skills.
"""

from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path


def _read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def _write_text(path: Path, content: str) -> None:
    path.write_text(content, encoding="utf-8")


def _list_prompt_names(codex_root: Path) -> list[str]:
    prompts_dir = codex_root / "prompts"
    return sorted(p.stem for p in prompts_dir.glob("*.md"))


def _list_skill_names(codex_root: Path) -> list[str]:
    skills_dir = codex_root / "skills"
    return sorted(p.name for p in skills_dir.iterdir() if p.is_dir())


def _rename_prompts(codex_root: Path, prefix: str, prompt_map: dict[str, str]) -> None:
    prompts_dir = codex_root / "prompts"
    for old in sorted(prompt_map.keys(), key=len, reverse=True):
        src = prompts_dir / f"{old}.md"
        dst = prompts_dir / f"{prompt_map[old]}.md"
        src.rename(dst)


def _rename_skills(codex_root: Path, prefix: str, skill_map: dict[str, str]) -> None:
    skills_dir = codex_root / "skills"
    for old in sorted(skill_map.keys(), key=len, reverse=True):
        src = skills_dir / old
        dst = skills_dir / skill_map[old]
        src.rename(dst)


def _rewrite_file(
    path: Path,
    prompt_map: dict[str, str],
    skill_map: dict[str, str],
    prefix: str,
) -> None:
    text = _read_text(path)
    original = text

    # Replace ${CLAUDE_PLUGIN_ROOT}/skills/<skill>/... with repo-local .codex path.
    # We do this before generic name rewrites so we can reuse the original skill name.
    def repl_claude_root(match: re.Match[str]) -> str:
        skill = match.group(1)
        rest = match.group(2)
        new_skill = skill_map.get(skill, f"ce-{skill}")
        return f".codex/skills/{new_skill}/{rest}"

    text = re.sub(
        r"\$\{CLAUDE_PLUGIN_ROOT\}/skills/([^/\s]+)/([^\s]*)",
        lambda m: repl_claude_root(m),
        text,
    )

    # Update /prompts:<name> references.
    for old in sorted(prompt_map.keys(), key=len, reverse=True):
        new = prompt_map[old]
        text = text.replace(f"/prompts:{old}", f"/prompts:{new}")

    # Update $<skill> references.
    for old in sorted(skill_map.keys(), key=len, reverse=True):
        new = skill_map[old]
        text = text.replace(f"${old}", f"${new}")

    # Update frontmatter `name: <skill>` for SKILL.md (and any other accidental hits).
    for old in sorted(skill_map.keys(), key=len, reverse=True):
        new = skill_map[old]
        # Keep it conservative: only replace when the whole line matches.
        text = re.sub(rf"(?m)^name:\s*{re.escape(old)}\s*$", f"name: {new}", text)

    # Upstream `plan_review` command references `@agent-<name>`; map to the actual agent skill when possible.
    def repl_agent_ref(match: re.Match[str]) -> str:
        inner = match.group(1)
        mapped = skill_map.get(inner)
        return f"${mapped}" if mapped else match.group(0)

    text = re.sub(r"\$agent-([a-z0-9_-]+)", repl_agent_ref, text)

    # Upstream `workflows:review` references `$general-purpose` as a placeholder; map to our shim skill.
    text = text.replace("$general-purpose", f"${prefix}general-purpose")

    if text != original:
        _write_text(path, text)


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--codex-root",
        default=".codex",
        help="Path to the project-local Codex root (default: .codex)",
    )
    ap.add_argument(
        "--prefix",
        default="ce-",
        help="Prefix to apply to prompts/skills (default: ce-)",
    )
    args = ap.parse_args(argv)

    codex_root = Path(args.codex_root).resolve()
    prefix = str(args.prefix)
    if not prefix:
        raise SystemExit("--prefix must be non-empty")

    prompts_dir = codex_root / "prompts"
    skills_dir = codex_root / "skills"
    if not prompts_dir.is_dir() or not skills_dir.is_dir():
        raise SystemExit(f"Expected {prompts_dir} and {skills_dir} to exist.")

    prompt_names = _list_prompt_names(codex_root)
    skill_names = _list_skill_names(codex_root)

    already_prefixed_prompts = prompt_names and all(name.startswith(prefix) for name in prompt_names)
    already_prefixed_skills = skill_names and all(name.startswith(prefix) for name in skill_names)

    if already_prefixed_prompts:
        # Map unprefixed name -> existing prefixed name.
        prompt_map = {name[len(prefix) :]: name for name in prompt_names}
    else:
        prompt_map = {name: f"{prefix}{name}" for name in prompt_names}

    if already_prefixed_skills:
        skill_map = {name[len(prefix) :]: name for name in skill_names}
    else:
        skill_map = {name: f"{prefix}{name}" for name in skill_names}

    # Rename files/dirs first (only when needed).
    if not already_prefixed_prompts:
        _rename_prompts(codex_root, prefix, prompt_map)
    if not already_prefixed_skills:
        _rename_skills(codex_root, prefix, skill_map)

    # Rewrite references inside prompts and skills.
    for path in sorted((codex_root / "prompts").glob("*.md")):
        _rewrite_file(path, prompt_map, skill_map, prefix)

    for path in sorted((codex_root / "skills").rglob("*")):
        if not path.is_file():
            continue
        # We mainly care about markdown docs, but paths in README-style files can exist.
        if path.suffix.lower() not in {".md", ".txt"} and path.name != "SKILL.md":
            continue
        _rewrite_file(path, prompt_map, skill_map, prefix)

    # Ensure shim skill exists when referenced by rewritten content.
    shim_dir = codex_root / "skills" / f"{prefix}general-purpose"
    shim_file = shim_dir / "SKILL.md"
    if not shim_file.exists():
        shim_dir.mkdir(parents=True, exist_ok=True)
        shim_file.write_text(
            (
                "---\n"
                f"name: {prefix}general-purpose\n"
                "description: Utility shim for converted Compound prompts that ask to \"use the general-purpose skill\".\n"
                "---\n\n"
                "# General Purpose Shim\n\n"
                f"Some converted Compound prompts reference `${prefix}general-purpose` as a placeholder for \"spawn a generic subagent to do X\".\n\n"
                "In Codex, treat the quoted instruction as a work item:\n\n"
                "1. Execute the instruction in the current thread using available tools (shell, file edits, etc.).\n"
                "2. If it contains a `/prompts:...` reference, run that prompt (or follow its corresponding skill).\n"
                "3. Report results concisely and include any validation commands you ran.\n\n"
                "If the work splits cleanly into independent shell reads/commands, parallelize those with `multi_tool_use.parallel`.\n"
            ),
            encoding="utf-8",
        )

    print("OK: prefixed prompts/skills and rewrote references")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
